

//:Part of me just wants to ditch this and try to 
//:write my own code from scratch. Am I really getting
//:much learning out of transcribing this and changing
//:around variable names?

//:PPPPPPPPPPPPPPPPPPPP[ PUFF.C : BELOW ]PPPPPPPPPPPPPPPPPPPP://
//:SUB_SECTION_INDEX:(BELOW):================================://
//:                                                          ://
//:GPC_HEL: Helper_Functions_Not_In_Original_PUFF.C          ://
//:                                                          ://
//:GPC_001: Defines/Consts                                   ://
//:         puff.c : C99 #define (Macros)                    ://
//:                                                          ://
//:GPC_002: NEW_gpc_sob(...) ( gpc_sob / poi_gpc_sob )       ://
//:         puff.c : struct state                            ://
//:         State object struct                              ://
//:                                                          ://
//:GPC_003: GPC_Bit(...)                                     ://
//:         puff.c : bits(...)                               ://
//:         Get sample bits from bytestream.                 ://
//:                                                          ://
//:GPC_004: GPC_Sto(...)                                     ://
//:         puff.c : stored(...)                             ://
//:         Process a stored (codes?) block.                 ://
//:                                                          ://
//:GPC_005: NEW_gpc_huf(...) && VAL_gpc_huf(...)             ://
//:         puff.c : struct huffman                          ://
//:         huffman ( table? ) struct.                       ://
//:                                                          ://
//:GPC_006: GPC_Dec_Slo(...)                                 ://
//:         puff.c : decode(...) (SLOW)                      ://
//:         Decode_a_code_from_stream.                       ://
//:                                                          ://
//:GPC_007: GPC_Dec_Fas(...)                                 ://
//:         puff.c : decode(...) (FAST)                      ://
//:         Decode_a_code_from_stream                        ://
//:                                                          ://
//:GPC_008: GPC_Con(...)                                     ://
//:         puff.c : construct(...)                          ://
//:         Construct canonical huffman code table           ://
//:         from a list of symbol frequencies.               ://
//:                                                          ://
//:GPC_009: GPC_Cod(...)                                     ://
//:         puff.c : codes(...)                              ://
//:         Decode until end of block.                       ://
//:                                                          ://
//:GPC_010: GPC_Fix(...)                                     ://
//:         puff.c : fixed(...)                              ://
//:         Process a fixed codes block                      ://
//:                                                          ://
//:GPC_011: GPC_Dyn(...)                                     ://
//:         puff.c : dynamic(...)                            ://
//:         Process a dynamic codes block.                   ://
//:                                                          ://
//:GPC_012: NEW_gpc_arg_puf(...)                             ://
//:         Does not exist in original puff.c                ://
//:         This argument object exist in .JS                ://
//:         version to cope with lack of pointers            ://
//:         in JavaScript.                                   ://
//:                                                          ://
//:GPC_013: GPC_Puf(...)                                     ://
//:         puff.c : puff(...)                               ://
//:                                                          ://
//:SUB_SECTION_INDEX:(ABOVE):================================://
//:GPC_HEL:==================================================://

    //:For declaring a file scope, stack-allocated array.
    const GPC_DEC_AND_INI_STA_CON_SHO=function(
        num_elm //:Number_Of_Elements
    ,   arr_elm //:Array__Of_Elements
    ){ "use strict"

        if( num_elm != arr_elm.length ){
            throw("[INITIALIZER_LIST_NOT_MATCH_DECLARED_SIZE]");
        };;

        //:In C code, this object will be stack allocated,
        //:NOT_Malloced.
        let arr_sho=( new Uint16Array( num_elm ) );

        for( let i = 0; i < num_elm; i++ ){
            arr_sho[ i ]=( arr_elm[ i ] );
        };;

        return( arr_sho );
    };;

//:==================================================:GPC_HEL://
//:GPC_001:==================================================://

    //:#PUFF_C_TRANSCRIBE#

    //:GPC:GEP_PUFF_C: Namespace for everything in this 
    //:                section. Not using "GEP" because
    //:                then I would have to prefix everything
    //:                with "GEP_PUF_*" and that is a bit
    //:                too verbose.

    const GPC_NUM_FIX = 288 ; //: NUMBER_FIXED_LITERAL_CODES
    const GPC_MAX_BIT =  15 ; //: MAX_BITS_IN_A_CODE 
    const GPC_MAX_LIT = 286 ; //: MAX_LITERAL_LENGTH_CODES
    const GPC_MAX_DIS =  30 ; //: MAX_NUMBER_OF_DISTANCE_CODES
    const GPC_MAX_L_D =(  0   //: MAX_CODE_LENGTHS_TO_READ
    +     GPC_MAX_LIT        
    +     GPC_MAX_DIS  );;

    //:CO:GPC_Cod:Static_Arrays:(BELOW):---------------------://
    //:COCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCO://
    //:[ puff.c lens == GPC_Cod_ARR_LEN ]
    /* Size base for length codes 257..285 */
    let GPC_Cod_ARR_LEN=GPC_DEC_AND_INI_STA_CON_SHO(29,[
    //::001: 002: 003: 004: 005: 006: 007: 008: 009: 010:::::://
    /**/  3,   4,   5,   6,   7,   8,   9,  10,  11,  13   //:01 
    ,    15,  17,  19,  23,  27,  31,  35,  43,  51,  59   //:02 
    ,    67,  83,  99, 115, 131, 163, 195, 227, 258        //:03 
    //::001: 002: 003: 004: 005: 006: 007: 008: 009: 010::::::// 
    ]);;

    //:[ puff.c lext == GPC_Cod_EXT_LEN ]
    /* Extra bits for length codes 257..285 */
    let GPC_Cod_EXT_LEN=GPC_DEC_AND_INI_STA_CON_SHO(29,[
    //::001: 002: 003: 004: 005: 006: 007: 008: ###: ###:::::://
    /**/  0,   0,   0,   0,   0,   0,   0,   0   //: 001 (8) ://
    ,     1,   1,   1,   1                       //: 002 (4) ://
    ,     2,   2,   2,   2                       //: 003 (4) ://
    ,     3,   3,   3,   3                       //: 004 (4) ://
    ,     4,   4,   4,   4                       //: 005 (4) ://
    ,     5,   5,   5,   5                       //: 006 (4) ://
    ,     0                                      //: 007 (1) ://
    //::001: 002: 003: 004: 005: 006: 007: 008: ###: ###:::::://
    ]);;

    //:[ puff.c dists == GPC_Cod_ARR_DIS ]
    /* Offset base for distance codes 0..29 */
    let GPC_Cod_ARR_DIS=GPC_DEC_AND_INI_STA_CON_SHO(30,[
    //::001:    002:    003:    004:    005:     //: ###     ://
    /**/  1,      2,      3,      4,      5      //: 001     ://
    ,     7,      9,     13,     17,     25      //: 002     ://
    ,    33,     49,     65,     97,    129      //: 003     ://
    ,   193,    257,    385,    513,    769      //: 004     ://
    ,  1025,   1537,   2049,   3073,   4097      //: 005     ://
    ,  6145,   8193,  12289,  16385,  24577      //: 006     ://
    //::001:    002:    003:    004:    005:     //: ###     ://
    ]);;

    //:[ puff.c dext == GPC_Cod_EXT_DIS ]
    /* Extra bits for distance codes 0..29 */
    let GPC_Cod_EXT_DIS=GPC_DEC_AND_INI_STA_CON_SHO(30,[
    //::001: 002: 003: 004: ###: ###: ###: ###: ###: ###:::::://
    /**/  0,   0,   0,   0  //:: 001  :://           //:-----://
    ,     1,   1,   2,   2  //:: 002  :://           //:-----://
    ,     3,   3            //:: 003  :://           //:-----://
    ,     4,   4            //:: 004  :://           //:-----://
    ,     5,   5            //:: 005  :://           //:-----://
    ,     6,   6            //:: 006  :://           //:-----://
    ,     7,   7            //:: 007  :://           //:-----://
    ,     8,   8            //:: 008  :://           //:-----://
    ,     9,   9            //:: 009  :://           //:-----://
    ,    10,  10            //:: 010  :://           //:-----://
    ,    11,  11            //:: 011  :://           //:-----://
    ,    12,  12            //:: 012  :://           //:-----://
    ,    13,  13            //:: 013  :://           //:-----://
    //::001: 002: 003: 004: ###: ###: ###: ###: ###: ###:::::://
    ]);;
    //:COCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCO://

    
    //: longjmp: Basically throwing an error.
    const GPC_Lon_Jum=function( j_b_env ){ "use strict"

        throw("[GPC:Lon_Jum:ERROR]");

    };;

    //: setjmp : If this were C code, the branch taken
    //:          changes if there was an error or not.
    //:          However, we don't have instruction
    //:          pointer manipulation in JavaScript,
    //:          so stub in to alway return NON-ERROR
    //:          code of zero.
    const GPC_Set_Jum=function( j_b_env ){ "use strict"

        return( 0 );

    };;

//:==================================================:GPC_001://
//:GPC_002:==================================================://

    //:# #poi_gpc_sob# #://
    const NEW_gpc_sob=function(){ "use strict"
    return(Object.seal({

        //: Conventions:
        //:       poi_*: Denote pointer type.
        //:       val_*: Denote value   type. (non-pointer)

        //:Observations:
        //:     inn_cou: Can be thought of as inn_pos
        //:     out_cou: Can be thought of as out_pos
        
        //:Output_State:
        //:     out_buf: Output Buffer
        //:     out_len: Available space at out_buf
        //:     out_cou: Bytes:WRITTEN_TO:out_buf:so_far

        //: Input_State:
        //:     inn_buf: Input_Buffer
        //:     inn_len: Available input at inn_buf
        //:     inn_cou: Bytes:READ_FROM::inn_buf:so_far
    
        //:     bit_buf: Bit_Buffer
        //:     bit_cou: Number_Of_Bits_In:bit_buf
        
        //:  MISC_OTHER:
        //:     j_b_env: Jump buffer environment

        vit : VIT_GPC_SOB

    ,   out_buf : POI_Unsigned_Char( )
    ,   out_len : VAL_Unsigned_Long( )
    ,   out_cou : VAL_Unsigned_Long( )
        
    ,   inn_buf : POI_Unsigned_Char( )
    ,   inn_len : VAL_Unsigned_Long( )
    ,   inn_cou : VAL_Unsigned_Long( )
    
    ,   bit_buf : VAL_Int( )
    ,   bit_cou : VAL_Int( )

    ,   j_b_env : VAL_Jum_Buf( )

    }));;};;

    const VAL_gpc_sob=function(){ "use strict"
    return( NEW_gpc_sob() );
    };;

//:==================================================:GPC_002://
//:GPC_003:==================================================://

    //+------------------------------------------------------+//
    //| Return [ val_nee_bit # bits ] from the input stream. |//
    //| Always leaves less than [ 8 ] bits in the buffer.    |//
    //| GPC_Bit() works properly for[ val_nee_bit == 0 ]     |//
    //|                                                      |//
    //| Format notes:                                        |//
    //|                                                      |//
    //| Bits are stored in bytes from the least significant  |//
    //| bit to the most significant bit. Therefore bits are  |//
    //| dropped from the bottom of the bit buffer,using shift|//
    //| right,and new bytes are appended to the top of the   |//
    //| bit buffer,using shift left.                         |//
    //|                                                      |//
    //| JMIM NOTE: This function is only dropping bits with  |//
    //|            RIGHT_SHIFT( >> ), nothing is being added |//
    //|            using LEFT_SHIFT( << )                    |//
    //+------------------------------------------------------+//
    const GPC_Bit=function( //://////////////////////////////://
        poi_gpc_sob /** Pointer to: gpc_sob   **/
    ,   val_nee_bit /** Needed_Number_Of_Bits **/
    ){ "use strict"

        //:NOTES:
        //:     (FORCE_SIGNED___SHIFT << X )>>0
        //:     (FORCE_UNSIGNED_SHIFT << X )>>>0

        //:The comments say we have a 20 bit accumulator,
        //:so I [[[ THINK ]]] it would be erroneous to ask
        //:for more than 20 bits. -JMIM
        if( val_nee_bit > 20 ){
            throw("[20_BIT_ACCUMULATOR:THINK_ERROR]");
        };;

        const SOB =( poi_gpc_sob       ); //:State_OBject
        const I_M =( 0xFFFFFFFF        ); //:Integer_Mask
        const L_M =( 0xFFFFFFFFFFFFFFFF); //:Long____Mask
 
        //:A 20 bit accumulator. 
        let bit_buf = VAL_Signed_Long(); 
            bit_buf = SOB.bit_buf;  
        while(  
            //:Load at least[ val_nee_bit ]into[ bit_buf ]
            SOB.bit_cou //:Bit___Count
            <   val_nee_bit //:Needed_Bits
        ){
            if( SOB.inn_cou  
            >=  SOB.inn_len
            ){
                //:ERROR:OUT_OF_INPUT:
                GPC_Lon_Jum( SOB.env, 1 );
            };;

            //+----------------------------------------------+//
            //|    +=( 1 )|[ inn_cou ]>>>>>>>>>>>>>>>>>| |//
            //|           |    0     |    1     |    2     | |//
            //|           | inn_cou  | inn_cou  | inn_cou  | |//
            //|           |          |          |          | |//
            //|inn_buf[ 11111111 | 11111111 | 11111111 ] |//
            //|           |    8     |    16    |    24    | |//
            //|           | bit_cou  | bit_cou  | bit_cou  | |//
            //|    +=( 8 )[ bit_cou ]>>>>>>>>>>>>>>>>>>| |//
            //+----------------------------------------------+//
            //|READ:>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>|//
            //|inn_buf[ 11111111 | 11111111 | 11111111 ]     |//
            //|    MSB[    A     |     B    |     C    ]LSB  |//
            //|            |           |                     |//
            //|            +----------------------+          |//
            //|                        |          |          |//
            //|    MSB(    C           B          A    )LSB  |//
            //|bit_buf( 11111111   11111111   11111111 )     |//
            //|<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<:WRITE|//
            //+----------------------------------------------+//

            //:Load 8 bits: //:888888888888888888888888888888://
            bit_buf = bit_buf | (

                (L_M) //:Hackish_Cast_To_Long_By_Masking
                &&
                (( 
                    SOB.inn_buf[ SOB.inn_cou ] 
                    << 
                    SOB.bit_cou
                )>>0)  //:Signed_Shift. Why bit_buf is
                       //:a signed integer, no clue.

            );; //:888888888888888888888888888888888888888888://

            (SOB.inn_cou)+=( 1 ); //:1 more byte(s) read.
            (SOB.bit_cou)+=( 8 ); //:8 more byte(s) load.

        };;

        //: Drop[ val_nee_bit ](s) and update buffer, 
        //: always[ 0 -to- 7 ]bits left. 
        SOB.bit_buf=(I_M)&((bit_buf >> val_nee_bit)>>0);
        //|                  |    20 bit integer cast    |   |//
        //|   OOB      OOB   |<----- & 0xFFFFFF -------->|   |//
        //| !!!!!!!! !!!!!!!! CCCCCCCC BBBBBBBB 87654321 |   |//
        //| val_nee_bit==8 :  >>>>>>>> CCCCCCCC BBBBBBBB |   |//
        
        //:Number of bits we just erased by pushing them
        //:off the edge like a [ coin pusher machine ].
        (SOB.bit_cou)=-( val_nee_bit ); 

        //|     |   0xFF  |   0xFF  |   0xFF  |              |//
        //| BIN: 0000 0000 0000 0000 0000 0001               |//
        //| <<<: 0000 0000 0000 0001 0000 0000 <<val_nee_bit |//
        //| SUB: 0000 0000 0000 0000 1111 1111  -1           |//
        //|                          \_______/               |//
        //|                            --+--                 |//
        //|                              |                   |//
        //|                             N_B                  |//
        const N_B=( ((0x00000001 << val_nee_bit)>>>0) -1);
        
        //:Return the bits you shoved off the edge
        //:of [ SOB.bit_buf ]
        const BIT=( (I_M)&(( bit_buf & N_B )) );

        return( BIT );

        /** #UNDEF( sob ) : State_Object_Bundle              **/
        /** #UNDEF( N_B ) : Needed_Bits                      **/
        /** #UNDEF( I_M ) : Integer_Mask for_hackish_cast    **/
        /** #UNDEF( L_M ) : Long____Mask for_hackish_cast    **/ 
        /** #UNDEF( BIT ) : The_Bits_You_Needed              **/
    };; //:///////////////////////////////////////| GPC_Bit |://

//:==================================================:GPC_003://
//:GPC_004:==================================================://

    //+------------------------------------------------------+//
    //| Process a stored block.                              |//
    //+------------------------------------------------------+//
    //| Format notes:                                        |//
    //+------------------------------------------------------+//
    //|After the two-bit stored block type (00),the stored   |//
    //|block length and stored bytes are byte-aligned for    |//
    //|fast copying. Therefore any leftover bits in the byte |//
    //|that has the last bit of the type,as many as seven,are|//
    //|discarded. The value of the discarded bits are not    |//
    //|defined and should not be checked against any         |//
    //|expectation.                                          |//
    //+------------------------------------------------------+//
    //|The second inverted copy of the stored block length   |//
    //|does not have to be checked,but it's probably a good  |//
    //|idea to do so anyway.                                 |//
    //+------------------------------------------------------+//
    //|A stored block can have zero length. This is sometimes|//
    //|used to byte-align                                    |//
    //+------------------------------------------------------+//
    const GPC_Sto=function(
        poi_gpc_sob /** Pointer to: gpc_sob   **/
    ){ "use strict"
    
        const SOB=( poi_gpc_sob             );
        const INN=( poi_gpc_sob.inn_buf );
        const OUT=( poi_gpc_sob.out_buf );

        let len=VAL_Unsigned_Int(); //:Length_Of_Stored_Block
        let chk=VAL_Unsigned_Int(); //:Error_Check_Compliment

        //:Discard leftover bits from current byte.
        //:Assumes ( SOB.bit_cou < 8 )
        if( SOB.bit_cou >= 8 ){
            throw("[GPC:Assumes:bit_cou:LessThan8]");
        };;
        SOB.bit_buf = 0;
        SOB.bit_cou = 0;

        //:==================================================://
        //:Get length & check against its one's compliment.
        //:Q: Why the +4 ? Because[ val_in_cou++ ]4 times?
        //:Q: Is 2 an error code for not enough input?
        //:Q: is len assumed to be a 16 bit short?
        //:==================================================://
        if( SOB.inn_cou + 4 > SOB.inn_len ){
            return( 0 + 2 ); /** Not enough Input **/
        }else{

            //|  INN[  AA , BB , CC , DD ]   ----------------|//
            //|  len(  BB   AA           )   ----------------|//
            //|  chk(            DD   CC )   ----------------|//
            len  =( 0x0000 );
            chk  =( 0x0000 );
            let AA = INN[ SOB.inn_cou++ ];
            let BB = INN[ SOB.inn_cou++ ];
            let CC = INN[ SOB.inn_cou++ ];
            let DD = INN[ SOB.inn_cou++ ];

            //+----------------------------------------------+//
            //| https://www.w3.org/Graphics/PNG/RFC-1951     |//
            //|                                              |//
            //|     0        1                               |//
            //|                                              |//
            //| +--------+--------+                          |//
            //|                                              |//
            //| |00001000|00000010|                          |//
            //|                                              |//
            //| +--------+--------+                          |//
            //|                                              |//
            //|  ^        ^                                  |//
            //|                                              |//
            //|  |        |                                  |//
            //|                                              |//
            //|  |        + more significant byte = 2 x 256  |//
            //|                                              |//
            //|  + less significant byte = 8                 |//
            //+----------------------------------------------+//

            len |=( AA << 0 )>>>0; //: 0x BB AA
            len |=( BB << 8 )>>>0; //: 0x BB AA
            chk |=( CC << 0 )>>>0; //: 0x CC DD
            chk |=( DD << 8 )>>>0; //: 0x CC DD

            if( len != ( ~chk ) ){
                /** Didn't match complement!**/
                return( 0 - 2 ); 
            };;
        };;
        //:==================================================://

        //| Copy len bytes from[ INN ]to[ OUT ]              |//
        //| As of DATE[2020_07_22] madler's puff.c has an    |//
        //| off-by-1 error in this comparison.               |//
        //| Line 182 of puff.c                               |//
        //| github.com/madler/                               |//
        //| zlib/blob/master/contrib/puff/puff.c             |//
        if( SOB.inn_cou + len  //:Last_Byte_Index
          > SOB.inn_len +  0   //:First_Out_Of_Bounds_Byte
    
            //|  The DATA[ index++ ] pattern I am seeing     |//
            //|  tells me inn_cou RESTS on data that     |//
            //|  has NOT been consumed yet.                  |//
            //|                                              |//
            //|  I think this code has a bug.                |//
            //|  CUR: inn_cou + len >  inn_len       |//
            //|  FIX: inn_cou + len >= inn_len       |//
            //|- - - - - - - - - - - -- - - - - - - - - - - -|//
            //|  IF:         len == 4                        |//
            //|  IF: inn_cou == 2                        |//
            //|  IF: inn_len == 7                        |//
            //|          |<--- TAKE 4 -->| OOB               |//
            //|  [ 0 | 1 | 2 | 3 | 4 | 5 ][ 6 ]              |//
            //|  [        cou  1   2   3    4 ]              |//
            //|  |<----- inn_len==7 ----->|              |//
            //|- - - - - - - - - - - -- - - - - - - - - - - -|//
            //|  If you have an array with 1 byte:           |//
            //|  And you try to take 2 bytes...              |//
            //|  SOB.inn_cou + 2 == ( 0 + 2 ) == 2       |//
            //|  SOB.inn_len =================== 1       |//
            //|  This is out of bounds, but ( 2 > 2 )        |//
            //|  is false.                                   |//
            //|                                              |//
            //|  Unless inn_cou starts counting at 1...  |//
            //|  But that wouldn't make sense.               |//
            //|  And... inn_cou does NOT.                |//
            //|- - - - - - - - - - - -- - - - - - - - - - - -|//
            //| NO. You are wrong. Comparison is ">" not ">="|//
            //|                                              |//
            //| [ 0 ]                                        |//
            //|   |                                          |//
            //|  cou==0                                      |//
            //|  cou+len==1 (if taking just 1)               |//
            //| ( cou + len ) > ( inn_len )              |//
            //| (  0  +  1  ) > (      1      ) ? NO         |//
            //|                                              |//
            //| Take 2 instead of 1.                         |//
            //| (  0  +  2  ) > (      1      ) ? YES        |//

        ){  

            //:Not enough input.
            //:JMIM NOTE: Seems that inn_cou
            //:           can be thought of as a "count"
            //:           or "seek position" variable.
            //:           I didn't get what this block was
            //:           for until I realized this.
            return( 2 ); 

        };;

        if( OUT != null ){

            //:                                              ://
            //:   out_cou == 0                           ://
            //:        |                                     ://
            //:     [ 0xFF ] <--OUT (output buffer)          ://
            //:                  out_len==1              ://
            //:                                              ://
            //:   Try taking 2 instead of 1 byte:            ://
            //:   ( out_cou + 2 ) > ( out_len )?     ://
            //:   Yes it is. Comparison is ">" NOT ">="      ://
            if( SOB.out_cou + len 
              > SOB.out_len 
            ){
                return( 1 ); //:Not enough output space.
            };;
            while( len-- ){
                OUT[ SOB.out_cou++ ]=(
                INN[ SOB.inn_cou++ ]
                );;
            };;

        }else{
            //:Just scanning.
            //:I think this is the 1st pass of a 2 pass hack.
            //:Algorithm requires you to know the final size
            //:of the decompressed data so you can allocate
            //:enough space for output buffer. Since I am going
            //:to use this code to deflate PNG files, I should
            //:NOT need this branch of code as I can calculate
            //:size of uncompressed data from headers.
            //:However, keeping the 2-pass method in might
            //:help avoid buffer overflow attacks since I can
            //:verify deflated data matches header.
            ( SOB.out_cou ) += ( len );
            ( SOB.inn_cou ) += ( len );
        };;
        
        return(  0  ); //:Return_Status_Code_Zero

    };; //:///////////////////////////////////////| GPC_Sto |://

//:==================================================:GPC_004://
//:GPC_005:==================================================://

    //+------------------------------------------------------+//
    //|  Huffman code decoding tables. count[1..MAX_BIT] is  |//
    //|  the number of symbols of each length,which for a    |//
    //|  canonical code are stepped through in order.        |//
    //|  symbol[] are the symbol values in canonical order,  |//
    //|  where the number of entries is the sum of the       |//
    //|  counts in count[]. The decoding process can be      |//
    //|  seen in the function decode() below.                |//
    //+------------------------------------------------------+//
    //|  JMIM_THOUGHT: You don't have to store the huffman   |//
    //|                tree with the data IF you have a      |//
    //|                predictable way to create the huffman |//
    //|                tree from frequency table.            |//
    //+------------------------------------------------------+//
    const NEW_gpc_huf=function(/**void**/){ "use strict"
    return(Object.seal({

    /**/    vit : (  VIT_GPC_HUF  )

        /* number of symbols of each length            */
        /* I think the name frequency (arr_fre) would  */
        /* make more sense here than count (arr_cou ). */
    ,   arr_fre : POI_Signed_Short()  //:Arrays_Are_Pointers
    ,   arr_sym : POI_Signed_Short()  //:Arrays_Are_Pointers

    }));};;

    //:Denotes either:
    //:     1: Stack allocated value type
    //:     2: Value type allocated as member of struct.
    //:     In other words, when coverting to C99, instances
    //:     of this function call with NOT result in malloc.
    const VAL_gpc_huf=function( /**void**/){ "use struct"
        return( NEW_gpc_huf() );
    };;

//:==================================================:GPC_005://
//:GPC_006:==================================================://

    //+------------------------------------------------------+//
    //|  GPC_Dec_Slo : decode (SLOW)                         |//
    //+------------------------------------------------------+//
    //|  Decode a code from the stream s using huffman       |//
    //|  table h. Return the symbol or a negative value if   |//
    //|  there is an error. If all of the lengths are zero,  |//
    //|  i.e. an empty code,or if the code is incomplete     |//
    //|  and an invalid code is received,then -10 is         |//
    //|  returned after reading MAX_BIT bits.                |//
    //+------------------------------------------------------+//
    //|  Format notes:                                       |//
    //+------------------------------------------------------+//
    //|  The codes as stored in the compressed data are      |//
    //|  bit-reversed relative to a simple integer ordering  |//
    //|  of codes of the same lengths. Hence below the bits  |//
    //|  are pulled from the compressed data one at a time   |//
    //|  and used to build the code value reversed from      |//
    //|  what is in the stream in order to permit simple     |//
    //|  integer comparisons for decoding. A table-based     |//
    //|  decoding scheme (as used in zlib) does not need to  |//
    //|  do this reversal.                                   |//
    //+------------------------------------------------------+//
    //|  The first code for the shortest length is all       |//
    //|  zeros. Subsequent codes of the same length are      |//
    //|  simply integer increments of the previous code.     |//
    //|  When moving up a length,a zero bit is appended to   |//
    //|  the code. For a complete code,the last code of the  |//
    //|  longest length will be all ones.                    |//
    //+------------------------------------------------------+//
    //|  JMIM NOTE:                                          |//
    //|     Canonical huffman codes are sorted first by      |//
    //|     bit length of their sequence. Then sequences     |//
    //|     that have the same length (frequency) are sorted |//
    //|     alphabetically.                                  |//
    //|                                                      |//
    //| CC |  AC |  BC |  CA |  CB |   AA |   AB |   BA | AB |//
    //| 10 | 110 | 001 | 111 | 011 | 0000 | 0001 | 0101 |0110|//
    //|  2 |   3 |   3 |   3 |   3 |    4 |    4 |    4 |   4|//
    //| 00 | 010 | 011 | 100 | 101 | 1100 | 1101 | 1110 |1111|//
    //| When you get to the next code length:                |//
    //|     1: Add 1 to previous code.                       |//
    //|     2: THEN append 0 to right hand side of code.     |//
    //|     3: You now have first code in the set of codes   |//
    //|        of that length.                               |//
    //|                                                      |//
    //| https://www.youtube.com/watch?v=yXM4wq_arB0          |//
    //|                                                      |//
    //|                                                      |//
    //+------------------------------------------------------+//
    //|  Incomplete codes are handled by this decoder,since  |//
    //|  they are permitted * in the deflate format. See     |//
    //|  the format notes for fixed() and dynamic().         |//
    //+------------------------------------------------------+//  
    //|#PCFN#                                                |//
    //|     #ifdef SLOW                                      |//
    //|          local int decode(                           |//
    //|              struct state *s                         |//
    //|          ,   const struct huffman *h)                |//
    //+------------------------------------------------------+//
    //|  GPC_Dec_Slo : decode (SLOW)                         |//
    //+------------------------------------------------------+//
    const GPC_Dec_Slo=function(
        poi_gpc_sob /** pointer to gpc_sob **/
    ,   poi_gpc_huf /** pointer to gpc_huf **/
    ){


    };; //:///////////////////////////////////| GPC_Dec_Slo |://


//:==================================================:GPC_006://
//:GPC_007:==================================================://


    //+------------------------------------------------------+//
    //|  GPC_Dec_Fas : decode (FAST)                         |//
    //+------------------------------------------------------+//
    //|A faster version of decode() for real applications of |//
    //|this code. It's not as readable,but it makes puff()   |//
    //|twice as fast. And it only makes the code a few       |//
    //|percent larger.                                       |//
    //|                                                      |//
    //|JMIM_COMMENT:                                         |//
    //|    By transcribing both the slow and fast methods,   |//
    //|    I can hackishly unit test by seeing if the two    |//
    //|    algorithms produce the same data.                 |//
    //+------------------------------------------------------+//
    //|  GPC_Dec_Fas : decode (FAST)                         |//
    //+------------------------------------------------------+//
    const GPC_Dec_Fas=function(
        poi_gpc_sob /** pointer to gpc_sob **/
    ,   poi_gpc_huf /** pointer to gpc_huf **/
    ){


    };; //:///////////////////////////////////| GPC_Dec_Fas |://
    

//:==================================================:GPC_007://
//:GPC_008:==================================================://

    //+======================================================+//
    //|  GPC_Con : Construct                                 |//
    //+======================================================+//
    //|  Given the list of code lengths length[0..NPI-1]     |//
    //|  representing a canonical Huffman code for NPI       |//
    //|  symbols,construct the tables required to decode     |//
    //|  those codes. Those tables are the number of codes   |//
    //|  of each length,and the symbols sorted by length,    |//
    //|  retaining their original order within each length.  |//
    //|  The return value is zero for a complete code set,   |//
    //|  negative for an over- subscribed code set,and       |//
    //|  positive for an incomplete code set. The tables     |//
    //|  can be used if the return value is zero or          |//
    //|  positive,but they cannot be used if the return      |//
    //|  value is negative. If the return value is zero,it   |//
    //|  is not possible for decode() using that table to    |//
    //|  return an error--any stream of enough bits will     |//
    //|  resolve to a symbol. If the return value is         |//
    //|  positive,then it is possible for decode() using     |//
    //|  that table to return an error for received codes    |//
    //|  past the end of the incomplete lengths.             |//
    //|                                                      |//
    //|JMIM: TL;DR ------------------------------------------|//
    //|     TABLES:                                          |//
    //|     1: Code lengths grouped by frequency.            |//
    //|                                                      |//
    //|     2:  Symbols sorted by length.                    |//
    //|         Same length symbols sorted lexographically.  |//
    //|         Aka: Symbols within group alphabetized.      |//
    //|                                                      |//
    //|RETURN_CODE(R_C)TABLE:                                |//
    //|     R_C| TYPE_OF_CODE_SET | USE ?  | CAN_THROW?|     |//
    //|     NEG: Over-Subscribed  ( NO_USE :   N/A     )     |//
    //|     ZER:        Complete  ( USABLE : NOTHROWME )     |//
    //|     POS:     IN-complete  ( USABLE : THROWABLE )     |//
    //|------------------------------------------------------|//    
    //|  Not used by decode(),but used for error checking,   |//
    //|  [ poi_gpc_huf->count[0] ] is the number of the      |//
    //|  [ NPI ] symbols not in the code.                    |//
    //|  So                                                  |//
    //|     ( NPI - (poi_gpc_huf.count[0] ) )                |//
    //|  is the number of codes.                             |//
    //|                                                      |//
    //|  This is useful for checking for incomplete codes    |//
    //|  that have more than one symbol,which is an error    |//
    //|  in a dynamic block.                                 |//
    //|------------------------------------------------------|//
    //|  Assumption:                                         |//
    //|  for all i in 0..NPI-1,0 <= length[i] <= MAXBITS     |//
    //|  This is assured by the construction of the length   |//
    //|  arrays in dynamic() and fixed() and is not          |//
    //|  verified by construct().                            |//
    //|------------------------------------------------------|//
    //|  JMIM TL;DR: arr_cod_len[#] is non-negative.         |//
    //|              arr_cod_len[#] is LESS than MAXBITS     |//
    //|                                                      |//
    //| Format notes:                                        |//
    //|                                                      |//
    //| - Permitted and expected examples of incomplete      |//
    //|   codes are one of the fixed codes and any code with |//
    //|   a single symbol which in deflate is coded as one   |//
    //|   bit instead of zero bits. See the format notes for |//
    //|   fixed() and dynamic().                             |//
    //|                                                      |//
    //|                                                      |//
    //|   - Within a given code length,the symbols are kept  |//
    //|   in ascending order for the code bits definition.   |//
    //+======================================================+//
    const GPC_Con=function(  //://///////////////////////////://
        poi_gpc_huf //: Pointer to huffman struct.           ://
    ,   arr_cod_len //: Code Lengths array, pointer to short.://
    ){  "use strict"//:///////////////////////////| GPC_Con |://

        //:TODO

    };; //:///////////////////////////////////////| GPC_Con |://
    //+======================================================+//

//:==================================================:GPC_008://
//:GPC_009:==================================================://
    
    //+------------------------------------------------------+//
    //|  GPC_Cod: GPC_Codes                                  |//
    //+------------------------------------------------------+//
    //|  Decode literal/length and distance codes until an   |//
    //|  end-of-block code.                                  |//
    //|------------------------------------------------------|//
    //|  Format notes:                                       |//
    //|------------------------------------------------------|//
    //|  Compressed data that is after the block type if     |//
    //|  fixed or after the code description if dynamic is   |//
    //|  a combination of literals and length/distance       |//
    //|  pairs terminated by and end-of-block code.          |//
    //|                                                      |//
    //|  Literals are simply Huffman coded bytes. A          |//
    //|  length/distance pair is a coded length followed by  |//
    //|  a coded distance to represent a string that occurs  |//
    //|  earlier in the uncompressed data that occurs again  |//
    //|  at the current location.                            |//
    //|                                                      |//
    //|  JMIM_UNDERSTANDING: - - - - - - - - - - - - - - - - |//
    //|                                                      |//
    //|  if( IS_COMPRESSED_DATA( data ) ){                   |//
    //|  if((AFT_BLK_TYP( dat ) && IS_FIX( data ) )          |//
    //|  || (AFT_COD_DES( dat ) && IS_DYN( data ) )          |//
    //|  ){                                                  |//
    //|      IS_COMBINATION:                                 |//
    //|          1. Literals                                 |//
    //|          2. [ length , distance ] pairs (len_dis)    |//
    //|          3. </end_of_block>                          |//
    //|                                                      |//
    //|  };;                                                 |//
    //|                                                      |//
    //|  LITERAL: Huffuman encoded byte.                     |//
    //|  len_dis: huffman  encoded byte with                 |//
    //|           "length" and "distance" values             |//
    //|           bitpacked into it. (I think)               |//
    //|                                                      |//
    //|------------------------------------------------------|//
    //|  Literals,lengths,and the end-of-block code are      |//
    //|  combined into a single code of up to 286 symbols.   |//
    //|  They are 256 literals (0..255),29 length symbols    |//
    //|  (257..285),and the end-of-block symbol (256).       |//
    //| - - - - - - - - - - - - ---- - - - - - - - - - - - - |//
    //|  [  0  - 255 ] : 0x000 - 0x0FF : LITERALS            |//
    //|  [ 256 - 256 ] : 0x100 - 0x100 : END_OF_BLOCK_SYMBOL |//
    //|  [ 257 - 285 ] : 0x101 - 0x11D : LENGTH Symbols      |//
    //|------------------------------------------------------|//
    //|  There are 256 possible lengths (3..258),and so 29   |//
    //|  symbols are not enough to represent all of those.   |//
    //|  Lengths 3..10 and 258 are in fact represented by    |//
    //|  just a length symbol. Lengths 11..257 are           |//
    //|  represented as a symbol and some number of extra    |//
    //|  bits that are added as an integer to the base       |//
    //|  length of the length symbol. The number of extra    |//
    //|  bits is determined by the base length symbol.       |//
    //|  These are in the static arrays below,lens[] for     |//
    //|  the base lengths and lext[] for the corresponding   |//
    //|  number of extra bits.                               |//
    //| - - - - - - - - - - - - ---- - - - - - - - - - - - - |//
    //|  [ 3 - 258 ]: 0x003 - 0x102 : Possible Lengths       |//
    //|  [ 3 -  10 ]: 0x003 - 0x00A : JUST_A_LENGTH_SYMBOL   |//
    //|  [   258   ]: 0x102 - 0x102 : JUST_A_LENGTH_SYMBOL   |//
    //|  [11 - 257 ]: 0x00B - 0x101 : SYMBOL_AND_EXTRA_BITS  |//
    //|------------------------------------------------------|//
    //|  The reason that 258 gets its own symbol is that     |//
    //|  the longest length is used often in highly          |//
    //|  redundant files. Note that 258 can also be coded    |//
    //|  as the base value 227 plus the maximum extra value  |//
    //|  of 31. While a good deflate should never do this,   |//
    //|  it is not an error,and should be decoded properly.  |//
    //|                                                      |//
    //|  ( 227 + 31 == 258 )                                 |//
    //|------------------------------------------------------|//
    //|  If a length is decoded,including its extra bits if  |//
    //|  any,then it is followed a distance code. There are  |//
    //|  up to 30 distance symbols. Again there are many     |//
    //|  more POSSIBLE_DISTANCES (1..32768),so extra bits    |//
    //|  are added to a base value represented by the        |//
    //|  symbol. The distances 1..4 get their own symbol,    |//
    //|  but the rest require extra bits. The base           |//
    //|  distances and corresponding number of extra bits    |//
    //|  are below in the static arrays dist[] and dext[].   |//
    //|                                                      |//
    //|  30                : NUMBER_OF_DISTANCE_SYMBOLS      |//
    //| [ 1      - 32768 ] : POSSIBLE_DISTANCES              |//
    //| [ 0x0001 - 0x8000] : POSSIBLE_DISTANCES              |//
    //|          [ 1 - 4 ] : GET_OWN_SYMBOL                  |//
    //|------------------------------------------------------|//
    //|  LITERAL_BYTES are simply written to the output. A   |//
    //|  LEN_DIST_PAIR pair is an instruction to copy        |//
    //|  previously uncompressed bytes to the output. The    |//
    //|  copy is from distance bytes back in the output      |//
    //|  stream,copying for length bytes.                    |//
    //|                                                      |//
    //|  LITERAL_BYTES: No data transformation. (  value)    |//
    //|  LEN_DIST_PAIR:    Backwards reference. (pointer)    |//
    //|------------------------------------------------------|//
    //|  Distances pointing before the beginning of the      |//
    //|  output data are not permitted.                      |//
    //|------------------------------------------------------|//
    //|  Overlapped copies,where the length is greater than  |//
    //|  the distance,are allowed and common. For example,a  |//
    //|  distance of one and a length of 258 simply copies   |//
    //|  the last byte 258 times. A distance of four and a   |//
    //|  length of twelve copies the last four bytes three   |//
    //|  times. A simple forward copy ignoring whether the   |//
    //|  length is greater than the distance or not          |//
    //|  implements this correctly. You should not use       |//
    //|  memcpy() since its behavior is not defined for      |//
    //|  overlapped arrays. You should not use memmove() or  |//
    //|  bcopy() since though their behavior -is- defined    |//
    //|  for overlapping arrays,it is defined to do the      |//
    //|  wrong thing in this case.                           |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|     Overflow is used to encode runline sequences.    |//
    //|     < B , L  > : < BACKWARDS_DISTANCE, LENGTH >      |//
    //|     < 1 , 40 > : "A"    copied 40 times.             |//
    //|     < 2 , 40 > : "AB"   copied 20 times.             |//
    //|     < 4 , 40 > : "ABCD" copied 10 times.             |//
    //|------------------------------------------------------|//
    //|PCFN:local int codes(...){...}                        |//
    //+------------------------------------------------------+//
    const GPC_Cod=function(
        poi_gpc_sob //:Pointer to state object
    ,   poi_huf_len //:Huffman Struct of[Length|Literal]Codes.
    ,   poi_huf_dis //:Huffman Struct of[   distance   ]Codes.
    ){ "use strict"

        //:##################################################://
        //: I am not going to [ declare | define ]           ://
        //: "INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR"     ://
        //: In this re-write of puff.c. I think it is a bad  ://
        //: idea, but left it here for completeness.         ://
        let BE_AN_IDIOT=(0-1);
        let BE_A_SMARTY=(0-1);
        if( INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR != 0 ){
            BE_AN_IDIOT=( 1 );
            BE_A_SMARTY=( 0 );
        }else{
            BE_AN_IDIOT=( 0 );
            BE_A_SMARTY=( 1 );
        };;
        if( BE_AN_IDIOT == BE_A_SMARTY ){
            throw("[CANT_BE_BOTH_AT_THE_SAME_TIME]");
        };;
        //:##################################################://

        let SOB=( poi_gpc_sob );
        let sym=GPC_DEC_SIG_INT(); /*  decoded sym   */
        let len=GPC_DEC_SIG_INT(); /*  len for copy  */
        let dis=GPC_DEC_UNS_INT(); /*  dis for copy  */
        
        /* ARR_LEN : Size   base for   length codes 257..285 */
        /* EXT_LEN : Extra  bits for   length codes 257..285 */
        /* ARR_DIS : Offset base for distance codes   0..29  */
        /* EXT_DIS : Extra  bits for distance codes   0..29  */
        const ARR_LEN=( GPC_Cod_ARR_LEN );
        const EXT_LEN=( GPC_Cod_EXT_LEN ); //:puff.c : lext
        const ARR_DIS=( GPC_Cod_ARR_DIS );
        const EXT_DIS=( GPC_Cod_EXT_DIS ); //:puff.c : dext

        //:DO:Do_Loop:(BELOW):-------------------------------://
        //:DODODODODODODODODODODODODODODODODODODODODODODODODO://
        //: decode_literals_and__length_distance__pairs      ://
        //:DODODODODODODODODODODODODODODODODODODODODODODODODO://
        do{  //:________________________| while_sym_NOT_256 |://

        //::symEGPC_Dec_SOB_len_cod
            sym=GPC_Dec(SOB,len_cod);  

        //::if_sym_L_0:________________________| if_sym_L_0 |://
            if(sym < 0){
                /* negative_sym_is_invalid */
                return sym;              
            }else
            if (sym < 256){            
                /**   256: literal: sym_is_the_byte **/  

                /* write_out_the_literal */
                if (SOB.out_buf != NIL) {

                    //:JMIM_COMMENT:I_THINK_THIS_IS_A_BOUNDS_CHECK
                    if( SOB.out_cou  //:GTE_DAS_EQT
                    ==  SOB.out_len  //:GTE_DAS_EQT
                    ){
                        return 1;
                    }else
                    if( SOB.out_cou  //:EXPECTED_ELSE
                    <   SOB.out_len  //:EXPECTED_ELSE
                    ){
                        SOB.out_buf[SOB.out_cou] = sym;
                    }else{
                        throw("[EDCL:2020_07_28:MMRWW]");
                    };;
                };;
                SOB.out_cou++;
            }else 
            if (sym > 256) {        
                /*  > 256 : GUESS:symbol_is_a_length_NOT_literal  */

                /* get_and_compute_length */
                    sym -= 257;  //:[ 257==0x101 ]
                if (sym >=  29){ //:[  29==0x01D ]
                    /* invalid_fixed_code */
                    return -10;             
                };;

                len = ARR_LEN[sym] + GPC_Bit(SOB, EXT_LEN[sym]);

                /* get_and_check_distance */
                sym = GPC_Dec(SOB, poi_huf_dis);
                if (sym < 0){
                    /* negative_sym_is_invalid */
                    return sym;          
                };;
                dis = ARR_DIS[sym] + GPC_Bit(SOB, EXT_DIS[sym]);
     
                //:D1:IfDef_Block:1:-------------------------://
                //:D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1://
                if( BE_AN_IDIOT > 0 ){

                    //:no_error_checking_if_you_are_being
                    //:an_idiot_and_allowing_corrupted_files

                }else
                if( BE_A_SMARTY > 0 ){

                    if (dis > SOB.out_cou){      
                         /* distance too far back */ 
                        return -11;                  
                    };;        
                }else{
                    throw("[EDCL:2020_07_28:BLUE_PENGUIN]");
                };;
                //:D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1D1://

                /* copy_length_bytes_from_distance_bytes_back */
                if(null !=SOB.out_buf){
                    if(  
                        ( SOB.out_cou + len )
                    >   ( SOB.out_len       )
                    ){
                        return 1;
                    };;
        
                    //:D2:IfDef_Block:2:---------------------://
                    //:D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2://
                    if( BE_AN_IDIOT > 0 ){
                    while (len--) { //:-------------| while |://
                        SOB.out_buf[SOB.out_cou]=(
                            dis > SOB.out_cou 
                            ?
                            0   
                            :
                            SOB.out_buf[
                           (SOB.out_cou - dis)]
                        );;
                        SOB.out_cou++;
                    };; //:-------------------------| while |://
                    }else
                    if( BE_A_SMARTY > 0 ){
                    while (len--) { //:-------------| while |://
                    
                        //:JMIM_COMMENT_BACKWARDS_REFERENCE::://
                        SOB.out_buf[SOB.out_cou      ]=(
                        SOB.out_buf[SOB.out_cou - dis] );;
                                        SOB.out_cou++;

                    };; //:-------------------------| while |://
                    }else{
                        throw("[EDCL:2020_07_28_1224PM]");
                    };;
                    //:D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2://
                }else{
                    SOB.out_cou += len;
                };;
            };;
        }while (sym != 256); //:________| while_sym_NOT_256 |://
        /* sym === 256 === end_of_block_sym */
        //:DODODODODODODODODODODODODODODODODODODODODODODODODO://
        //:DO:Do_Loop:(ABOVE):-------------------------------://
    
        /* done with a valid fixed or dynamic block */
        return 0;

        GPC_UND(     SOB );
        GEP_UND( ARR_LEN );
        GEP_UND( EXT_LEN );
        GEP_UND( ARR_DIS );
        GEP_UND( EXT_DIS );
    };; //:///////////////////////////////////////| GPC_Cod |://

//:==================================================:GPC_009://
//:GPC_010:==================================================://
    
    //+------------------------------------------------------+//
    //|  GPC_Fix : GPC_Fixed                                 |//
    //+------------------------------------------------------+//
    //|  Process a fixed codes block.                        |//
    //|------------------------------------------------------|//
    //|  Format notes:                                       |//
    //|------------------------------------------------------|//
    //|  This block type can be useful for compressing       |//
    //|  small amounts of data for which the size of the     |//
    //|  code descriptions in a dynamic block exceeds the    |//
    //|  benefit of custom codes for that block. For fixed   |//
    //|  codes,no bits are spent on code descriptions.       |//
    //|  Instead the code lengths for literal/length codes   |//
    //|  and distance codes are fixed. The specific lengths  |//
    //|  for each symbol can be seen in the "for" loops      |//
    //|  below.                                              |//     
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  I think this means that no meta-data like           |//
    //|  a huffman tree, huffman table, or frequency table   |//
    //|  is encoded alongside "fixed" type data.             |//
    //|------------------------------------------------------|//                                                        
    //|  The literal/length code is complete,but has two     |//
    //|  symbols that are invalid and should result in an    |//
    //|  error if received. This cannot be implemented       |//
    //|  simply as an incomplete code since those two        |//
    //|  symbols are in the "middle" of the code. They are   |//
    //|  eight bits long and the longest literal/length      |//
    //|  code is nine bits. Therefore the code must be       |//
    //|  constructed with those symbols,and the invalid      |//
    //|  symbols must be detected after decoding.            |//                                                     
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  Detected after decoding HOW much data?              |//
    //|  Like 2 passes over all the data, or having to       |//
    //|  intermittenly look backwards every once and         |//
    //|   a while to see if there was an error?              |//
    //|                                                      |//
    //|  JMIM_COMMENT: (My understanding of above)           |//
    //|  Erroneous data somehow does not evenly fit          |//
    //|  into bytes and therefor is hard to detect           |//
    //|  immediately.                                        |//
    //|------------------------------------------------------|//
    //|  The fixed distance codes also have two invalid      |//
    //|  symbols that should result in an error if           |//
    //|  received. Since all of the distance codes are the   |//
    //|  same length,this can be implemented as an           |//
    //|  incomplete code. Then the invalid codes are         |//
    //|  detected while decoding.                            |//
    //|                                                      |//
    //|  JMIM_COMMENT: The two invalid distance codes can    |//
    //|                be detected quickly on the fly        |//
    //|                since all distance codes are the      |//
    //|                same number of bits and thus          |//
    //|                can be easily scanned by some         |//
    //|                type of scrolling data viewport.      |//
    //|------------------------------------------------------|//
    //|  TL;DR:                                              |//
    //|     1: Fixed codes for small compressed blocks.      |//
    //|     2: Two TRAP [literal/length] codes denote error. |//
    //|     3: Two TRAP [   distance   ] codes denote error. |//
    //+------------------------------------------------------+//
    const GPC_Fix=function(
        poi_gpc_sob
    ){ "use strict"


    };; //:///////////////////////////////////////| GPC_Fix |://

//:==================================================:GPC_010://
//:GPC_011:==================================================://

    //+------------------------------------------------------+//
    //| GPC_Dyn : GPC_Dynamic                                |//
    //+------------------------------------------------------+//
    //|  Process a dynamic codes block.                      |//
    //|------------------------------------------------------|//
    //|  Format notes:                                       |//
    //|------------------------------------------------------|//
    //|  A dynamic block starts with a description of the    |//
    //|  literal/length and distance codes for that block.   |//
    //|  New dynamic blocks allow the compressor to rapidly  |//
    //|  adapt to changing data with new codes optimized     |//
    //|  for that data.                                      |//
    //|------------------------------------------------------|//
    //|  The codes used by the deflate format are            |//
    //|  "canonical",which means that the actual bits of     |//
    //|  the codes are generated in an unambiguous way       |//
    //|  simply from the number of bits in each code.        |//
    //|  Therefore the code descriptions are simply a list   |//
    //|  of code lengths for each symbol.                    |//
    //| - - - - - - - - - - - - ---- - - - - - - - - - - - - |//
    //|  JMIM_COMMENT:                                       |//
    //|  So the data is NOT sorted in any way to begin with. |//
    //|  Your job to group symbols by LEN and then           |//
    //|  lexographically sort within each group of           |//
    //|  same LEN before assigning the proper canonical      |//
    //|  huffman code.                                       |//
    //|                                                      |//
    //|  JMIM_COMMENT:( MY GUESS )                           |//
    //|  1: LEN = ARR_LEN[ SYMBOL ]                          |//
    //|  2: GROUP SYMBOL by LEN.                             |//
    //|  3: Lexographically sort each SYMBOL within GROUP.   |//
    //|------------------------------------------------------|//
    //|  The code lengths are stored in order for the        |//
    //|  symbols,so lengths are provided for each of the     |//
    //|  literal/length symbols,and for each of the          |//
    //|  distance symbols.                                   |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|                                                      |//
    //|  Don't know what this means.                         |//
    //|  "Code lengths are stored in order for the symbols"  |//
    //|  So... Does that mean:                               |//
    //|                                                      |//
    //|  1. Ordered+Grouped by length                        |//
    //|     AND symbols within each group sorted.            |//
    //|                                                      |//
    //|  2. Simply Ordered by length. Which implies          |//
    //|     grouping, of symbols by length, but no           |//
    //|     sorting within group.                            |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  Don't know what this means:                         |//
    //|  "So lengths are provided for each of the    "       |//
    //|  "literal/length symbols, and for each of the"       |//
    //|  "distance symbols.                          "       |//
    //|                                                      |//
    //|  Since huffman tree can be derived just from         |//
    //|  frequency (length) information when using canonical |//
    //|  huffman codes, I think this means there are         |//
    //|  two huffman table structs. One for "literal/length" |//
    //|  codes and one for "distance" codes.                 |//
    //|                                                      |//
    //|  ...Even if that is what they are saying...          |//
    //|  ...I don't know why "so" is used. That implies      |//
    //|  a "causation" or "necessitation".                   |//
    //|------------------------------------------------------|//
    //|  If a symbol is not used in the block,this is        |//
    //|  represented by a zero as as the code length. This   |//
    //|  does not mean a zero-length code,but rather that    |//
    //|  no code should be created for this symbol. There    |//
    //|  is no way in the deflate format to represent a      |//
    //|  zero-length code.                                   |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  If symbol is NOT in encoded data:                   |//
    //|     1: It is denoted by FREQUENCY (lenght) zero.     |//
    //|     2: Don't waste bits creating code for symbol.    |//
    //|                                                      |//
    //|  Example: If your text file is:                      |//
    //|  "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"         |//
    //|  You only need one huffman code. So in binary        |//
    //|  we could represent this text file as:               |//
    //|  "00000000000000000000000000000000000000000"         |//
    //|  assuming "A" is one SYMBOL.                         |//
    //|                                                      |//
    //|  Obviously, we cannot express other symbols if       |//
    //|  our huffman code is this short. But doesn't matter  |//
    //|  since the frequency (length) table has declared     |//
    //|  that no other symbols exist.                        |//
    //|------------------------------------------------------|//
    //|                                                      |//
    //|  The maximum number of bits in a code is 15,         |//
    //|  so the possible lengths for any code are 1..15.     |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  Code length is measured in bits.                    |//
    //|  1111   : A  : Symbol "A" stored in code length==4.  |//
    //|  111000 : B  : Symbol "B" stored in code length==6.  |//
    //|                                                      |//
    //|------------------------------------------------------|//
    //|  The fact that a length of zero is not permitted     |//
    //|  for a code has an interesting consequence.          |//
    //|  Normally if only one symbol is used for a given     |//
    //|  code,then in fact that code could be represented    |//
    //|  with zero bits. However in deflate,that code has    |//
    //|  to be at least one bit. So for example,if only a    |//
    //|  single distance base symbol appears in a block,     |//
    //|  then it will be represented by a single code of     |//
    //|  length one,in particular one 0 bit. This is an      |//
    //|  incomplete code,since if a 1 bit is received,it     |//
    //|  has no meaning,and should result in an error. So    |//
    //|  incomplete distance codes of one symbol should be   |//
    //|  permitted,and the receipt of invalid codes should   |//
    //|  be handled.                                         |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  If you only have 1 symbol, say "A".                 |//
    //|  Then your current block is just a bunch of          |//
    //|  "A" symbols like:                                   |//
    //|  "AAAAAAAAAAAAAAAAAAAAAAAAA"                         |//
    //|  And can be encoded as:                              |//
    //|  "0000000000000000000000000"                         |//
    //|  But then WTF does:                                  |//
    //|  "1111111111111111111111111"                         |//
    //|  Mean if you have only 1 symbol but 2 binary values? |//
    //|                                                      |//
    //|  ANSWER: "0" doesn't mean anything!                  |//
    //|  IMPLICATION:                                        |//
    //|     1. The most compact way to encode "A" is "1"     |//
    //|     2. Single "1" bit is not a complete huffman code.|//
    //|     3. We must allow incomplete huffman codes.       |//
    //|------------------------------------------------------|//
    //|  It is also possible to have a single                |//
    //|  literal/length code,but that code must be the       |//
    //|  end-of-block code,since every dynamic block has     |//
    //|  one. This is not the most efficient way to create   |//
    //|  an empty block (an empty fixed block is fewer       |//
    //|  bits),but it is allowed by the format. So           |//
    //|  incomplete literal/length codes of one symbol       |//
    //|  should also be permitted.                           |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  An incomplete literal code of 1 bit can be used     |//
    //|  to denote an empty block. It isn't the most         |//
    //|  compact way to express it, but it is expressable    |//
    //|  under the rules and thus must be allowed.           |//
    //|                                                      |//
    //|  Real world analogy:                                 |//
    //|  var A = ( 10 ); //:Valid JavaScript, expresses 10.  |//
    //|  var A = ( 1+1+1+1+1+1+1+1+1+1 ); //:Also_Valid      |//
    //|                                                      |//
    //|  TL;DR: [ Valid/Legal != Good_Idea ]                 |//
    //|------------------------------------------------------|//
    //|  If there are only literal codes and no lengths,     |//
    //|  then there are no distance codes. This is           |//
    //|  represented by one distance code with zero bits.    |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  References are stored as:                           |//
    //|  < distance backwards in bits , length in bits >     |//
    //|                                                      |//
    //|  If there are NO reference, you still need the       |//
    //|  "Length_Or_Literal" table. Because literals.        |//
    //|                                                      |//
    //|  But since the literal table contains no LENGTH(s)   |//
    //|  Then there are no LENGTHS(S) to be paired with      |//
    //|  distances, and the distances table can be empty.    |//
    //|------------------------------------------------------|//
    //|  The list of up to 286 length/literal lengths and    |//
    //|  up to 30 distance lengths are themselves            |//
    //|  compressed using Huffman codes and run-length       |//
    //|  encoding. In the list of code lengths,a 0 symbol    |//
    //|  means no code,a 1..15 symbol means that length,and  |//
    //|  the symbols 16,17,and 18 are run-length             |//
    //|  instructions. Each of 16,17,and 18 are follwed by   |//
    //|  extra bits to define the length of the run. 16      |//
    //|  copies the last length 3 to 6 times. 17 represents  |//
    //|  3 to 10 zero lengths,and 18 represents 11 to 138    |//
    //|  zero lengths. Unused symbols are common,hence the   |//
    //|  special coding for zero lengths.                    |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  Yo dawg I heard you liked huffman codes so I got    |//
    //|  you some huffman codes for your huffman codes so    |//
    //|  that you can decode while you decode.               |//
    //|                                                      |//
    //|  JMIM_QUESTION:                                      |//
    //|  What is a "0" code. Is that...                      |//
    //|     1: A "0" bit?                                    |//
    //|     2: A "0" byte?                                   |//
    //|  I "THINK" the word "symbol" means "index value"     |//
    //|  as accessor to an [ array / table ] here.           |//
    //|                                                      |//
    //|  Hmm.. "symbol" is only an array index if it is      |//
    //|  a value [ 1 - 15 ] inclusive... So...               |//
    //|  "Symbol" means a "value". But when we say "symbol"  |//
    //|  we mean "collection of bits"?                       |//
    //|                                                      |//
    //|  Huffman encoding encodes "symbols" and some symbols |//
    //|  can be "literal" and others are <distance, jumpback>|//
    //|  pairs so... "collection of bits" I think is an      |//
    //|  accurate understanding of author's use of the       |//
    //|  word "symbol" here.                                 |//
    //|------------------------------------------------------|//
    //|  The symbols for 0..18 are Huffman coded,and so      |//
    //|  that code must be described first. This is simply   |//
    //|  a sequence of up to 19 three-bit values             |//
    //|  representing no code (0) or the code length for     |//
    //|  that symbol (1..7).                                 |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|                                                      |//
    //|  SYM_0_18[ 0 ]=binary( "000" ); //:Decimal: 0        |//
    //|  SYM_0_18[ 1 ]=binary( "001" ); //:Decimal: 1        |//
    //|  SYM_0_18[ 2 ]=binary( "010" ); //:Decimal: 2        |//
    //|  SYM_0_18[ 3 ]=binary( "011" ); //:Decimal: 3        |//
    //|  SYM_0_18[ 4 ]=binary( "100" ); //:Decimal: 4        |//
    //|  SYM_0_18[ 5 ]=binary( "101" ); //:Decimal: 5        |//
    //|  SYM_0_18[ 6 ]=binary( "110" ); //:Decimal: 6        |//
    //|  SYM_0_18[ 7 ]=binary( "111" ); //:Decimal: 7        |//
    //|  SYM_0_18[...]..                                     |//
    //|  SYM_0_18[18 ] <--LAST_ENTRY                         |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|                                                      |//
    //|  This doesn't sound like "huffman coded" this sounds |//
    //|  more like "3 bit integer". I guess in a way it is   |//
    //|  technically a huffman code.                         |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|                                                      |//
    //|  Wait. No.. The frequency table SYM_0_18 is an       |//
    //|  array of 3-bit integers. Arrays are just contiguous |//
    //|  strips of memory. The canonical huffman codes       |//
    //|  still need to be generated from this frequency      |//
    //|  table.                                              |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  The author's original comment was correct, but      |//
    //|  for a second I thought it was written               |//
    //|  in a nonsensical but technically correct way.       |//
    //|------------------------------------------------------|//
    //|  A dynamic block starts with three fixed-size        |//
    //|  counts from which is computed the number of         |//
    //|  literal/length code lengths,the number of distance  |//
    //|  code lengths,and the number of code length code     |//
    //|  lengths (ok,you come up with a better name!) in     |//
    //|  the code descriptions.                              |//
    //| - - - - - - - - - - - - ---- - - - - - - - - - - - - |//
    //|  JMIM_COMMENT:                                       |//
    //|  Dynamic Block Header:                               |//
    //|     UNIQUE_LENGTH[ 0 ]: literal/length               |//
    //|     UNIQUE_LENGTH[ 1 ]: distance codes               |//
    //|     UNIQUE_LENGTH[ 2 ]: code lengths                 |//
    //|                                                      |//
    //|  For example: If you have:                           |//
    //|  4 distance codes:                                   |//
    //|             "1111"                                   |//
    //|             "1001"                                   |//
    //|             "0110"                                   |//
    //|             "0000"                                   |//
    //|  And NO OTHER DISTANCE CODES.                        |//
    //|  Then:                                               |//
    //|     UNIQUE_LENGTH[ 1 ] == 1                          |//
    //|                                                      |//
    //| - - - - - - - - - - - - ---- - - - - - - - - - - - - |//
    //|  For the literal/length and                          |//
    //|  distance codes,lengths after those provided are     |//
    //|  considered zero,i.e. no code. The code length code  |//
    //|  lengths are received in a permuted order (see the   |//
    //|  order[] array below) to make a short code length    |//
    //|  code length list more likely. As it turns out,very  |//
    //|  short and very long codes are less likely to be     |//
    //|  seen in a dynamic code description,hence what may   |//
    //|  appear initially to be a peculiar ordering.         |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  I "THINK" they are saying:                          |//
    //|  " The hardcoded data looks weird but trust us "     |//
    //|  " we got these numbers by observation.        "     |//
    //|------------------------------------------------------|//
    //|  Given the number of literal/length code lengths     |//
    //|  (num_len) and distance code lengths (num_dis),then they  |//
    //|  are treated as one long list of num_len + num_dis code   |//
    //|  lengths. Therefore run-length coding can and often  |//
    //|  does cross the boundary between the two sets of     |//
    //|  lengths.                                            |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  The two lists are in to sub-sections (partitions)   |//
    //|  of the same array, and decompression algorithm      |//
    //|  just sees one big chunk of bits. Don't worry.       |//
    //|------------------------------------------------------|//
    //|  So to summarize,the code description at the start   |//
    //|  of a dynamic block is three counts for the number   |//
    //|  of code lengths for the literal/length codes,the    |//
    //|  distance codes,and the code length codes. This is   |//
    //|  followed by the code length code lengths,three      |//
    //|  bits each. This is used to construct the code       |//
    //|  length code which is used to read the remainder of  |//
    //|  the lengths. Then the literal/length code lengths   |//
    //|  and distance lengths are read as a single set of    |//
    //|  lengths using the code length codes. Codes are      |//
    //|  constructed from the resulting two sets of lengths  |//
    //|  ,and then finally you can start decoding actual     |//
    //|  compressed data in the block.                       |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  1: Header:                                          |//
    //|     Header[ 0 ]: HGH:[Literal/Length (codes)]        |//
    //|     Header[ 1 ]: HGH:[Distance       (codes)]        |//
    //|     Header[ 2 ]: HGH:[Code Lengths   (codes)]        |//
    //|                                                      |//
    //|  2: Code length code lengths. 3 bits each.           |//
    //|     Use to decode the REST of the code lengths       |//
    //|     to follow.                                       |//
    //|                                                      |//
    //|  3: Read [literal/length]+[distance] tables.         |//
    //|                                                      |//
    //|  4: Construct huffman codes.                         |//
    //|                                                      |//
    //|  5. Decode the compressed data using the huffman     |//
    //|     codes created in steps [1-4].                    |//
    //|------------------------------------------------------|//
    //|                                                      |//                           
    //|  For reference, a "typical" size for the code        |//
    //|  description in a dynamic block is around 80 bytes.  |//
    //|                                                      |//
    //+------------------------------------------------------+//
    //| GPC_Dyn : GPC_Dynamic                                |//
    //+------------------------------------------------------+//
    //[ #PCFN#[ local int dynamic(struct state *s) ]         ]//
    const GPC_Dyn=function( 
        poi_gpc_sob /** pointer to gpc_sob **/ 
    ){ "use strict"

        const SOB=( poi_gpc_sob );

        //:JMIM NOTE: Pretty sure where author of puff.c
        //:           says "count" they mean "frequency".
        //:           Within this function anyhow. In other
        //:           functions within puff.c "count" means
        //:           a position in an array.

        //:Original Comment:Number of lengths in descriptor 
        let num_len ;  //: Length_Of_Something_Not_Sure      ://
        let num_dis ;  //: Number_Of_Distances_I_Guess       ://
        let num_cod ;  //: Number_Of_Codes_Of_Some_Sort      ://
                                                           
        let     dex ;  //: index of lengths[ ]               ://
        let     err ;  //: construct() return value          ://

        //:Original "puf.c" declares these inside loop,
        //:I don't know why since.
        //:     1. No variable collision if declared here.
        //:     2. Declaring in loop is wasteful.
        //:     3. Author usually front loads var declarations.
        let     sym ;  //: symbol: decoded value             ://
        let     len ;  //: len   : last length to repeat     ://

    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://

        //://////////////////////////////////////////////////://

        //: JMIM NOTE: Not 100% sure these variable re-names ://
        //:            are properly descriptive as I am      ://
        //:            re-naming based on PUFF.C original    ://
        //:            name and comment information.         ://
        //:            Will stick with these names until     ://
        //:            done porting function. Then will      ://
        //:            re-asses if names are good.           ://
        //: JMIM NOTE: [ len_fre ]AND[ len_sym ] might be    ://
        //:            better named [ lal_fre ]AND[ lal_sym ]://
        //:            For [ literal_and_length ].           ://
        //:            QUOTE: RFC_1951:                      ://
        //:            "using one code tree for literals"    ://
        //:            "and lengths and a separate code "    ://
        //:            "tree for distances ...          "    ://

    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://
        
        //: Signed short arrays (0xFFFF / BYTE*2) holding
        //: different types of data. Remember that arrays
        //: are always pointers to a datatype in C99.
        //: arr_l_d : lengths[MAXCODES]
        let arr_l_d = GEP_VAL_arr_sho( MAX_L_D );

        //: arr_len_fre: len_fre ( len_cou / lencnt[MAXBITS+1] )
        //: arr_len_sym: len_sym (           lensym[MAXLCODES] )
        let len_fre = GEP_VAL_arr_sho( MAX_BIT + 1 );
        let len_sym = GEP_VAL_arr_sho( MAX_LIT     );

        //: arr_len_fre: len_fre ( len_cou /distcnt[MAXBITS+1] )
        //: arr_len_sym: len_sym (          distsym[MAXDCODES] )
        let dis_fre = GEP_VAL_arr_sho( MAX_BIT + 1 );
        let dis_sym = GEP_VAL_arr_sho( MAX_DIS     );

        //://////////////////////////////////////////////////://

        let len_cod = VAL_gpc_huf( ); //:lencode
        let dis_cod = VAL_gpc_huf( ); //:distcode

        //:JMIM Hack. Create pointer variable for
        //:huffan structs so less calls to meaningless
        //:"GEP_POI" function. GEP_POI is used to
        //:denote  "&" operator. Or, GEP_AOS 
        //:GEP_AOS=="AddressOfStruct"
        let poi_len_cod=GEP_AOS( len_cod );
        let_poi_dis_cod=GEP_AOS( dis_cod );

    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://

        //:Permuations of code length codes:            -----://
        //:SEE[    www.w3.org/Graphics/PNG/RFC-1951 ]   -----://
        //:SEARCH[ 10, 5, 11, 4, 12, 3              ]   -----://
        //:SECTION[                                     -----://
        //:     3.2.7. Compression with dynamic         -----://
        //:     Huffman codes (BTYPE=10)                -----://
        //:]SECTION                                     -----://
        let     ord = GEP_VAL_arr_sho( 19 );
                ord[ 0 ]=( 16 ); //: 0x10 , b: 0001_0000
                ord[ 1 ]=( 17 ); //: 0x11 , b: 0001_0001
                ord[ 1 ]=( 18 ); //: 0x12 , b: 0001_0010
                ord[ 1 ]=(  0 ); //: 0x00 , b: 0000_0000
                ord[ 1 ]=(  8 ); //: 0x08 , b: 0000_1000
                ord[ 1 ]=(  7 ); //: 0x07 , b: 0000_0111
                ord[ 1 ]=(  9 ); //: 0x09 , b: 0000_1001
                ord[ 1 ]=(  6 ); //: 0x06 , b: 0000_0110
                ord[ 1 ]=( 10 ); //: 0x0A , b: 0000_1010
                ord[ 1 ]=(  5 ); //: 0x05 , b: 0000_0101
                ord[ 1 ]=( 11 ); //: 0x0B , b: 0000_1011
                ord[ 1 ]=(  4 ); //: 0x04 , b: 0000_0100
                ord[ 1 ]=( 12 ); //: 0x0C , b: 0000_1100
                ord[ 1 ]=(  3 ); //: 0x03 , b: 0000_0011
                ord[ 1 ]=( 13 ); //: 0x0D , b: 0000_1101
                ord[ 1 ]=(  2 ); //: 0x02 , b: 0000_0002
                ord[ 1 ]=( 14 ); //: 0x0E , b: 0000_1110
                ord[ 1 ]=(  1 ); //: 0x01 , b: 0000_0001
                ord[ 1 ]=( 15 ); //: 0x0F , b: 0000_1111
                //: {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 
                //:     4, 12, 3, 13, 2, 14, 1, 15}
    
    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://

        /** construct len_cod and dis_cod **/
        //:--------------------------------------------------://
        len_cod.arr_fre=( len_fre );
        len_cod.arr_sym=( len_sym );

        dis_cod.arr_fre=( dis_fre );
        dis_cod.arr_sym=( dis_sym );
        //:--------------------------------------------------://

        /* get number of lengths in each table, check lengths */
        num_len = GPC_Bit(SOB, 5) + 257; /** nlen  **/
        num_dis = GPC_Bit(SOB, 5) +   1; /** ndist **/
        num_cod = GPC_Bit(SOB, 4) +   4; /** ncode **/

        if(num_len > MAX_LIT //:Literals_Or_Lengths
        || num_dis > MAX_DIS //:Distances_Backwards
        ){
            return -3;      /* bad counts */
        };;

        /** read code length code lengths (really), **/
        /** missing lengths are zero                **/
        for (dex = 0; dex < num_cod; dex++){
            arr_l_d[ ord[dex] ] = GPC_Bit(SOB, 3);
        };;
        for (; dex < 19; dex++){
            arr_l_d[ ord[dex] ] = 0;
        };;

    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://

        //:C:Code_Length_Codes:------------------------------://
        //:CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC://
        //:  build huffman table for code lengths codes      ://
        //:  (use poi_len_cod temporarily)                   ://
        //:CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC://
        
            //:CONSTRUCT:::::::::::::::::::::::::::::::::::::://
            err =(  construct(
            /**/        poi_len_cod
            /**/    ,   arr_l_d
            /**/    ,   19
            ) /***/ );;
        
            //:CHECK_FOR_PROBLEMS::::::::::::::::::::::::::::://
            if (err != 0){  
                /* require complete code set here */
                return -4;
            };;
        //:CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC://

        //: read :
        //:     1: [ length/literal ] CODE_LENGTH_TABLES
        //:     2: [    distance    ] CODE_LENGTH_TABLES
        dex = 0;
    //::while_dex_L_num_len_P_num_dis::::::::::::::::::::::::://
        while(dex < num_len + num_dis ){

            //:DECODE_SYMBOL_USING_STATE_OBJECT::::::::::::::://
            sym = GPC_Dec(SOB, poi_len_cod);

            //:HANDLE_SYMBOL:
            //:     sym <  0 : INVALID
            //:     sym < 16 : Literal Symbol Length [ 0 - 15 ]
            //:     sym== 16 : RUN_LENGTH_ENCODING : [ 3 - 6  ]
            //:     sym== 17 : RUN_LENGTH_ENCODING : [ 3 - 10 ]
            //:     sym== 18 : RUN_LENGTH_ENCODING : [11 -138 ]
            if (sym < 0){
                /* invalid sym */
                return sym;          
            }else
            if (sym < 16){

                /* length in 0..15 */
                arr_l_d[dex++] = sym;

            }else{ //:REPEAT_INSTRUCTION ------------------- ://
                         
                /* assume repeating zeros */
                len = 0;     
               
                if( 16 == sym ){   
                    //:  - - - -://
                    if (dex == 0){

                        /* no last length! */
                        return -5;  

                    }else{
                        /* last length */

                        len = arr_l_d[dex - 1];   

                        //:2_BITS: 11 : 0x3 : 3
                        //:2_BITS + DECIMAL_3 == 6
                        /* repeat last length 3..6 times */
                        sym = 3 + GPC_Bit(SOB, 2);
                    };;
                }else 
                if( 17 == sym ){

                    //: 3_BITS: 111 : 0x7 : 7
                    //: 3_BITS + DECIMAL_3 == 10
                    /* repeat zero 3..10 times */
                    sym = 3 + GPC_Bit(SOB, 3);

                }else
                if( 18 == sym ){
                    //: 7_BITS: 11 1 111 : 0x7F : 127
                    //: 7_BITS + DECIMAL_11 == 138
                    /* == 18, repeat zero 11..138 times */
                    sym = 11 + GPC_Bit(SOB, 7);
                }else{
                    //:In the orignal PUF.C the last 
                    //:case for "18" was just an "else".
                    //:But I would like to be more explicit.
                    throw("[EDCL:THE_18_CASE_IN_PUFF_C]");
                };;

                if (dex + sym > num_len + num_dis){
                    /* too many lengths! */
                    return -6;              
                };;

                /* repeat last or zero sym times */
                while( sym-- ){
                   
                    arr_l_d[ dex++ ] = len;

                };;

            };; //: ---------------------- REPEAT_INSTRUCTION://
        };; //::::::::::::::::::while_dex_L_num_len_P_num_dis://

    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://

        /* check for end-of-block code -- there better be one! */
        if ( 0 == arr_l_d[256] ){
            return( 0 - 9 );
        };;

    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://

        //:L:Literal:----------------------------------------://
        //:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://
        //:build huffman table for literal/length codes      ://
        //:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://

            //:CONSTRUCT:::::::::::::::::::::::::::::::::::::://
            err = construct(
            /**/poi_len_cod //:PointerTo:::::LOL_CODE
            ,       arr_l_d //:lengths ( of what? )
            ,       num_len //:NumberOfCodes:LOL_CODE
            );;

            //:CHECK_FOR_PROBLEMS::::::::::::::::::::::::::::://
            if( err != 0 ){
                if( err < 0 ){
                
                    return( 0 - 7 );

                }else
                if( err > 0 ){ 
                    let num_fre=( 
                        0
                        +   len_cod.arr_fre[0] //:AKA:count[0]
                        +   len_cod.arr_fre[1] //:AKA:count[1]
                    );;
                    if( num_len  != //: TYPE:LEN (LengthCodes )
                        num_fre     //:CHECK:FRE (FrequencySum)
                    ){
                        /* incomplete code ok only for */
                        /* single length 1 code        */
                        return( 0 - 7 );
                    };;
                }else{

                    throw("[EDCL:2020_07_27:A]");
                };;
            }else
            if( err == 0 ){
                //:No error, do nothing.
            }else{
                throw("[EDCL:2020_07_27:B]");
            };;

        //:LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL://

    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://

        //:D:Distance:---------------------------------------://
        //:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD://
        //:build huffman table for distance codes            ://
        //:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD://

            //:CONSTRUCT:::::::::::::::::::::::::::::::::::::://
            err = construct(

                poi_dis_cod //:PointerTo:::::DistanceCodes
            ,
                    arr_l_d //:WHAT_THE_HELL_IS_THIS_FOR? [WTF]
                   +num_len //:WHAT_THE_HELL_IS_THIS_FOR? [WTF]
            ,
                    num_dis //:NumberOfCodes:DistanceCodes
            );;

            //:CHECK_FOR_PROBLEMS::::::::::::::::::::::::::::://
            if( err != 0 ){
                if( err < 0 ){
                
                    return( 0 - 8 );

                }else
                if( err > 0 ){ 
                    let num_fre=( 
                        0
                        +   dis_cod.arr_fre[0] //:AKA:count[0]
                        +   dis_cod.arr_fre[1] //:AKA:count[1]
                    );;
                    if( num_dis  != //: TYPE:DIS (DistanceCodes)
                        num_fre     //:CHECK:FRE (FrequencySum )
                    ){
                        /* incomplete code ok only for */
                        /* single length 1 code        */
                        return( 0 - 8 );
                    };;
                }else{

                    throw("[EDCL:2020_07_27:C]");
                };;
            }else
            if( err == 0 ){
                //:No error, do nothing.
            }else{
                throw("[EDCL:2020_07_27:D]");
            };;

        //:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD://

    //:GPC_Dyn- - - - - - - - - -==- - - - - - - - - -GPC_Dyn://

        /* decode data until end-of-block code */
        return(
            GPC_Cod(
                SOB         //:puff.c : State_Object_Bundle
            ,   poi_len_cod //:huffman: LOL__CODES
            ,   poi_dis_cod //:huffman: DIST_CODES
            )
        );;


        GPC_UND( SOB ); /** #undef SOB **/
    };; //:///////////////////////////////////////| GPC_Dyn |://

//:==================================================:GPC_011://
//:GPC_012:==================================================://

    const NEW_gpc_arg_puf=function(/**void**/){ "use strict"
    return(Object.seal({

        //: val_arg_puf == VAL_gpc_arg_puf );
        //: poi_arg_puf == &(  val_arg_puf );

    /**/        vit : (  VIT_GPC_ARG_PUF  )

        /* des_arr : pointer to destination pointer */
        /* des_len : amount of output space         */
    ,      des_arr : MEM_UnsignedCharPointer()
    ,      des_len : MEM_UnsignedLongPointer()
                
        /* sou_arr : pointer to source data pointer */
        /* sou_len : amount of input available      */
    ,      sou_arr : MEM_ConstUnsignedCharPointer()
    ,      sou_len : MEM_UnsignedLongPointer()

    }));};;

    //:Denotes either:
    //:     1: Stack allocated value type
    //:     2: Value type allocated as member of struct.
    //:     In other words, when coverting to C99, instances
    //:     of this function call with NOT result in malloc.
    const VAL_gpc_arg_puf=function( /**void**/){ "use struct"
        return( NEW_gpc_arg_puf() );
    };;

//:==================================================:GPC_012://
//:GPC_013:==================================================://

    //+------------------------------------------------------+//
    //|  Inflate source to dest. On return,destlen and       |//
    //|  sourcelen are updated to the size of the            |//
    //|  uncompressed data and the size of the deflate data  |//
    //|  respectively. On success,the return value of        |//
    //|  puff() is zero. If there is an error in the source  |//
    //|  data,i.e. it is not in the deflate format,then a    |//
    //|  negative value is returned. If there is not enough  |//
    //|  input available or there is not enough output       |//
    //|  space,then a positive error is returned. In that    |//
    //|  case,destlen and sourcelen are not updated to       |//
    //|  facilitate retrying from the beginning with the     |//
    //|  provision of more input data or more output space.  |//
    //|  In the case of invalid inflate data (a negative     |//
    //|  error),the dest and source pointers are updated to  |//
    //|  facilitate the debugging of deflators.              |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|     We need to change this around a bit since        |//
    //|     JavaScript cannot pass around integers by        |//
    //|     reference. Unless you pass it an array of        |//
    //|     1 element, but that might be error prone.        |//
    //|                                                      |//
    //|     Using an arry of length 1 might be what          |//
    //|     you call "too clever".                           |//
    //|------------------------------------------------------|//
    //|  puff() also has a mode to determine the size of     |//
    //|  the uncompressed output with no output written.     |//
    //|  For this dest must be (unsigned char *)0. In this   |//
    //|  case,the input value of *destlen is ignored,and on  |//
    //|  return *destlen is set to the size of the           |//
    //|  uncompressed output.                                |//
    //|                                                      |//
    //|  JMIM_COMMENT:                                       |//
    //|  (unsigned char *)0 is a fancy way of saying         |//
    //|  NIL/NULL                                            |//
    //|                                                      |//
    //|------------------------------------------------------|//
    //|  The return codes are:                               |//
    //|                                                      |//
    //|      2:  available inflate data did not terminate    |//
    //|                                                      |//
    //|      1:  output space exhausted before               |//
    //|          completing inflate                          |//
    //|                                                      |//
    //|      0:  successful inflate                          |//
    //|    - 1:  invalid block type (type == 3)              |//
    //|    - 2:  stored block length did not match           |//
    //|          one's complement                            |//
    //|    - 3:  DBCD: too many length or distance codes     |//
    //|    - 4:  DBCD: code lengths codes incomplete         |//
    //|    - 5:  DBCD: repeat lengths with no first length   |//
    //|    - 6:  DBCD: repeat more than specified lengths    |//
    //|    - 7:  DBCD: invalid literal/length code lengths   |//
    //|    - 8:  DBCD: invalid distance code lengths         |//
    //|    - 9:  DBCD: missing end-of-block code             |//
    //|    -10:  invalid literal/length or distance code     |//
    //|          in fixed or dynamic block                   |//
    //|    -11:  distance is too far back in                 |//
    //|          fixed or dynamic block                      |//
    //|    -13:  JMIM Addition. Invalid block type           |//
    //|          that is NOT (type==3)                       |//
    //|------------------------------------------------------|//
    //|  Format notes:                                       |//
    //|------------------------------------------------------|//
    //|  Three bits are read for each block to determine     |//
    //|  the kind of block and whether or not it is the      |//
    //|  last block. Then the block is decoded and the       |//
    //|  process repeated if it was not the last block.      |//
    //|------------------------------------------------------|//
    //|  The leftover bits in the last byte of the deflate   |//
    //|  data after the last block (if it was a fixed or     |//
    //|  dynamic block) are undefined and have no expected   |//
    //|  values to check.                                    |//
    //+------------------------------------------------------+//
    //| GPC_Puf: GPC_Puff (puff.c: puff(...)                 |//
    //+------------------------------------------------------+//
    const GPC_Puf=function(
        poi_arg_puf /** AKA: gpc_arg_puf / arg_puf / ARG **/
    ){
        const ARG=( poi_arg_puf );

        let sob = VAL_gpc_sob( ); /** input/ output state **/
        let las =( 0 ); /* last: block information */
        let typ =( 0 ); /* type: block information */
        let err =( 0 ); /*  err: return value      */

        /* initialize output state */
        /* out_len: ignored if dest is NIL */
        sob.out_buf = ARG.des_arr;
        sob.out_len = ARG.des_len; 
        sob.out_cou =( 0 );

        /* initializer input state */   
        sob.inn_buf = ARG.sou_arr;
        sob.inn_len = ARG.sou_len;
        sob.inn_cou = 0;

        sob.bit_buf = 0;
        sob.bit_cou = 0;

        /* JMIM Addition: Pointer object to state object */
        /* to reduce pointless calls to "GEP_POI" that   */
        /* are only there to help transcribe back to C.  */
        let poi_sob=GEP_POI( sob );

        /* return if bits() or decode()       */
        /* tries to read past available input */
        if (GPC_Set_Jum(sob.j_b_env) != 0){     

            /* if came back here via longjmp() */
            /* then skip do-loop, return error */

            err = 2;    
                               
        }else{
            /* process blocks until last block or error */
            do {

                /* las : one if last block */
                /* typ : block type 0..3   */
                las = GPC_Bit( poi_sob, 1); 
                typ = GPC_Bit( poi_sob, 2); 

                if( 0 == typ ){ 
                    err = GPC_Sto( poi_sob );
                }else
                if( 1 == typ ){
                    err = GPC_Fix( poi_sob );
                }else
                if( 2 == typ ){
                    err = GPC_Dyn( poi_sob );
                }else
                if( 3 == typ ){
                    err = ( 0 - 1 );
                }else{
                    err = ( 0 - 13);
                };;

                if (err != 0){
                    /* return with error */
                    break;         
                };;
            } while ( las == 0 );
        };;

        /* update the lengths and return */
        if (err <= 0) {
            ARG.des_len = sob.out_cou;
            ARG.sou_len = sob.inn_cou;
        }
        return err;

        GEP_UND( ARG ); /** #undef arg **/
    };; //:///////////////////////////////////////| GPC_Puf |://
        
//:==================================================:GPC_013://
//:GPC_###:==================================================://

    GEP_UND( GPC_NUM_FIX /** puff.c : FIXLCODES    **/ );
    GEP_UND( GPC_MAX_BIT /** puff.c : MAXBITS      **/ );
    GEP_UND( GPC_MAX_LIT /** puff.c : MAXLCODES    **/ );
    GEP_UND( GPC_MAX_DIS /** puff.c : MAXDCODES    **/ );
    GEP_UND( GPC_MAX_L_D /** puff.c : MAXCODES     **/ );
 
//:PPPPPPPPPPPPPPPPPPPP[ PUFF.C : ABOVE ]PPPPPPPPPPPPPPPPPPPP://